<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
<title>–ú–∞–ª–æ–†–∏—Å–∞ ‚Äî –ó–º–µ–π–∫–∞</title>

<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

<style>
:root{
  --bg:#111;
  --panel:#1c1c1c;
  --canvas:#000;
  --text:#fff;
  --accent:#ff6b9a;
  --grid:#1a1a1a;
}
body.light{
  --bg:#f3f3f3;
  --panel:#fff;
  --canvas:#e6e6e6;
  --text:#111;
  --grid:#d0d0d0;
}

*{margin:0;padding:0;box-sizing:border-box}
body{
  background:var(--bg);
  color:var(--text);
  font-family:system-ui,sans-serif;
  display:flex;
  flex-direction:column;
  align-items:center;
  height:100vh;
  touch-action:none;
}

header{
  width:100%;
  padding:12px;
  background:var(--panel);
  display:flex;
  justify-content:space-between;
  align-items:center;
}

.title{
  font-family:'Press Start 2P', monospace;
  font-size:14px;
  color:var(--accent);
}

.btn-ui{
  padding:6px 10px;
  border-radius:10px;
  background:#2a2a2a;
  color:#fff;
  user-select:none;
}
body.light .btn-ui{background:#ddd;color:#000}

canvas{
  background:var(--canvas);
  border-radius:14px;
  margin:10px 0;
  image-rendering:pixelated;
}

.controls{
  display:grid;
  grid-template-columns:repeat(3,70px);
  grid-template-rows:repeat(2,70px);
  gap:10px;
}
.btn{
  background:#222;
  border-radius:14px;
  display:flex;
  justify-content:center;
  align-items:center;
  font-size:28px;
}
body.light .btn{background:#ddd;color:#000}
.btn:active{background:var(--accent)}
.up{grid-column:2}
.left{grid-column:1}
.down{grid-column:2}
.right{grid-column:3}

.overlay{
  position:fixed;
  inset:0;
  background:var(--bg);
  display:flex;
  flex-direction:column;
  justify-content:center;
  align-items:center;
  z-index:10;
}

.logo{
  font-family:'Press Start 2P', monospace;
  font-size:24px;
  color:var(--accent);
  margin-bottom:30px;
  animation:float 2.5s ease-in-out infinite;
}
@keyframes float{
  0%{transform:translateY(0)}
  50%{transform:translateY(-12px)}
  100%{transform:translateY(0)}
}

.pixel-btn{
  font-family:'Press Start 2P', monospace;
  padding:16px 28px;
  border-radius:14px;
  background:var(--accent);
  color:#000;
}

.small{font-size:12px;margin-top:8px}
</style>
</head>

<body>

<div class="overlay" id="start">
  <div class="logo">–ú–ê–õ–û–†–ò–°–ê</div>
  <div class="pixel-btn" id="play">–ò–ì–†–ê–¢–¨</div>
</div>

<div class="overlay" id="over" style="display:none">
  <div class="logo" style="animation:none">GAME OVER</div>
  <div class="small">
    –°—á–µ—Ç: <span id="finalScore">0</span> |
    –†–µ–∫–æ—Ä–¥: <span id="finalRecord">0</span>
  </div>
  <div class="pixel-btn" id="restart">–°–ù–û–í–ê</div>
</div>

<header>
  <span id="score">0</span>
  <span class="title">–ú–ê–õ–û–†–ò–°–ê</span>
  <span style="display:flex;gap:6px;align-items:center">
    <span id="record">0</span>
    <span class="btn-ui" id="sound">üîä</span>
    <span class="btn-ui" id="pause">‚è∏</span>
    <span class="btn-ui" id="theme">‚òÄÔ∏é / üåô</span>
  </span>
</header>

<canvas id="game" width="320" height="320"></canvas>

<div class="controls">
  <div></div><div class="btn up">‚ñ≤</div><div></div>
  <div class="btn left">‚óÄ</div><div class="btn down">‚ñº</div><div class="btn right">‚ñ∂</div>
</div>

<script>
(() => {
  const $ = (id) => document.getElementById(id)

  // DOM
  const canvas = $("game")
  const ctx = canvas.getContext("2d")
  ctx.imageSmoothingEnabled = false

  const UI = {
    start: $("start"),
    over: $("over"),
    play: $("play"),
    restart: $("restart"),
    score: $("score"),
    record: $("record"),
    finalScore: $("finalScore"),
    finalRecord: $("finalRecord"),
    pause: $("pause"),
    theme: $("theme"),
    sound: $("sound"),
  }

  // Constants
  const BOX = 20
  const COLS = canvas.width / BOX
  const ROWS = canvas.height / BOX
  const TICK_MS = 150
  const FOODS = ["üç£","üçü","üçî","üçï"]

  // Persistent settings
  let record = Number(localStorage.getItem("malorisa_record") || 0)
  let soundOn = localStorage.getItem("malorisa_sound") !== "0"

  UI.record.textContent = record
  UI.finalRecord.textContent = record
  UI.sound.textContent = soundOn ? "üîä" : "üîá"

  // Audio (safe start after user gesture)
  let audioCtx = null
  const initAudio = async () => {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)()
    // On mobile, context may be "suspended" until user gesture.
    if (audioCtx.state === "suspended") {
      try { await audioCtx.resume() } catch {}
    }
  }
  const beep = (freq, dur = 0.1) => {
    if (!soundOn || !audioCtx) return
    const o = audioCtx.createOscillator()
    const g = audioCtx.createGain()
    o.type = "square"
    o.frequency.setValueAtTime(freq, audioCtx.currentTime)
    g.gain.setValueAtTime(0.08, audioCtx.currentTime)
    o.connect(g).connect(audioCtx.destination)
    o.start()
    o.stop(audioCtx.currentTime + dur)
  }

  const vibrate = (ms = 20) => {
    if (navigator.vibrate) navigator.vibrate(ms)
  }

  // State
  const State = {
    mode: "start", // start | playing | paused | dying | gameover
    snake: [],
    dir: { x: 1, y: 0 },
    food: { x: 5, y: 5, icon: "üç£" },
    score: 0,

    // Animations
    pop: null,      // {x,y,t, dur}
    chomp: null,    // {t, dur}
    death: null,    // {t, dur, particles: [...]}
  }

  // Helpers
  const cellToPx = (c) => c * BOX
  const now = () => performance.now()

  const spawnFood = () => {
    let f
    do {
      f = {
        x: Math.floor(Math.random() * COLS),
        y: Math.floor(Math.random() * ROWS),
        icon: FOODS[Math.floor(Math.random() * FOODS.length)],
      }
    } while (State.snake.some(p => p.x === f.x && p.y === f.y))
    State.food = f
  }

  const startGame = () => {
    State.snake = [{ x: 10, y: 10 }]
    State.dir = { x: 1, y: 0 }
    State.score = 0
    State.mode = "playing"

    State.pop = null
    State.chomp = null
    State.death = null

    UI.score.textContent = "0"
    UI.pause.textContent = "‚è∏"
    spawnFood()
  }

  const endGame = () => {
    State.mode = "gameover"

    if (State.score > record) {
      record = State.score
      localStorage.setItem("malorisa_record", String(record))
    }

    UI.record.textContent = record
    UI.finalRecord.textContent = record
    UI.finalScore.textContent = State.score
    UI.over.style.display = "flex"
  }

  const beginDeathAnimation = () => {
    // Build particles from snake body (pixel crumble)
    const particles = []
    const parts = State.snake

    // each segment -> 4 particles (2x2 blocks) for retro crumble
    for (const seg of parts) {
      const baseX = cellToPx(seg.x) + 1
      const baseY = cellToPx(seg.y) + 1
      const w = BOX - 2

      // 2x2 micro-pixels inside segment (simple + stable)
      const offsets = [
        { ox: 2, oy: 2 },
        { ox: w - 6, oy: 2 },
        { ox: 2, oy: w - 6 },
        { ox: w - 6, oy: w - 6 },
      ]

      for (const o of offsets) {
        const px = baseX + o.ox
        const py = baseY + o.oy
        particles.push({
          x: px,
          y: py,
          vx: (Math.random() - 0.5) * 0.8,
          vy: 0.4 + Math.random() * 1.2,
          size: 4, // crisp pixel
          life: 1,
        })
      }
    }

    State.mode = "dying"
    State.death = { t: now(), dur: 460, particles }
  }

  const setDir = (x, y) => {
    // No direction changes during death animation
    if (State.mode === "dying" || State.mode === "start" || State.mode === "gameover") return
    // Prevent reversing into self immediately (classic rule)
    if (State.dir.x === -x && State.dir.y === -y) return
    State.dir = { x, y }
  }

  const togglePause = () => {
    if (State.mode === "dying" || State.mode === "start" || State.mode === "gameover") return
    State.mode = (State.mode === "paused") ? "playing" : "paused"
    UI.pause.textContent = (State.mode === "paused") ? "‚ñ∂" : "‚è∏"
  }

  // Game tick (fixed speed, no difficulty scaling)
  let lastTick = now()
  const tick = () => {
    if (State.mode !== "playing") return

    const head = State.snake[0]
    const nx = (head.x + State.dir.x + COLS) % COLS
    const ny = (head.y + State.dir.y + ROWS) % ROWS
    const newHead = { x: nx, y: ny }

    // Collision with self -> death animation
    if (State.snake.some(p => p.x === newHead.x && p.y === newHead.y)) {
      beginDeathAnimation()
      return
    }

    State.snake.unshift(newHead)

    // Eat
    if (newHead.x === State.food.x && newHead.y === State.food.y) {
      State.score++
      UI.score.textContent = String(State.score)

      // Animations: pop + chomp
      const t = now()
      State.pop = { x: State.food.x, y: State.food.y, t, dur: 210 }
      State.chomp = { t, dur: 170 }

      // Feedback
      beep(880)
      vibrate(20)

      spawnFood()
    } else {
      State.snake.pop()
    }
  }

  // Rendering
  const drawGrid = () => {
    const grid = getComputedStyle(document.body).getPropertyValue("--grid").trim()
    ctx.strokeStyle = grid
    ctx.lineWidth = 1

    // Vertical
    for (let i = 0; i <= COLS; i++) {
      const x = i * BOX + 0.5
      ctx.beginPath()
      ctx.moveTo(x, 0)
      ctx.lineTo(x, canvas.height)
      ctx.stroke()
    }
    // Horizontal
    for (let i = 0; i <= ROWS; i++) {
      const y = i * BOX + 0.5
      ctx.beginPath()
      ctx.moveTo(0, y)
      ctx.lineTo(canvas.width, y)
      ctx.stroke()
    }
  }

  const drawFood = () => {
    ctx.font = "18px serif"
    ctx.textBaseline = "alphabetic"
    ctx.fillText(State.food.icon, cellToPx(State.food.x) + 2, cellToPx(State.food.y) + 18)
  }

  const drawPop = (t) => {
    if (!State.pop) return
    const { x, y, t: t0, dur } = State.pop
    const p = (t - t0) / dur
    if (p >= 1) { State.pop = null; return }

    // 3 frames pop square: small -> medium -> big -> fade
    const frame = p < 0.33 ? 1 : (p < 0.66 ? 2 : 3)
    const size = frame === 1 ? 6 : (frame === 2 ? 10 : 14)

    const cx = cellToPx(x) + BOX / 2
    const cy = cellToPx(y) + BOX / 2

    const accent = getComputedStyle(document.body).getPropertyValue("--accent").trim()
    ctx.fillStyle = accent

    // draw hollow square (retro ring)
    const half = size / 2
    ctx.fillRect(Math.round(cx - half), Math.round(cy - half), size, 2)
    ctx.fillRect(Math.round(cx - half), Math.round(cy + half - 2), size, 2)
    ctx.fillRect(Math.round(cx - half), Math.round(cy - half), 2, size)
    ctx.fillRect(Math.round(cx + half - 2), Math.round(cy - half), 2, size)
  }

  const drawSnake = (t) => {
    const head = State.snake[0]
    if (!head) return

    // chomp scale
    let headScale = 1
    if (State.chomp) {
      const p = (t - State.chomp.t) / State.chomp.dur
      if (p >= 1) {
        State.chomp = null
      } else {
        // 0..1..0 bump
        const bump = Math.sin(p * Math.PI)
        headScale = 1 + bump * 0.12
      }
    }

    // colors
    const headColor = "#ffd1e1"
    const bodyColor = "#ff6b9a"

    for (let i = 0; i < State.snake.length; i++) {
      const s = State.snake[i]
      const x = cellToPx(s.x) + 1
      const y = cellToPx(s.y) + 1
      const w = BOX - 2
      const h = BOX - 2

      if (i === 0) {
        // scaled head around center
        const cx = x + w / 2
        const cy = y + h / 2
        const sw = w * headScale
        const sh = h * headScale

        ctx.fillStyle = headColor
        ctx.fillRect(
          Math.round(cx - sw / 2),
          Math.round(cy - sh / 2),
          Math.round(sw),
          Math.round(sh)
        )

        drawHeadEyes(cx, cy, headScale)
      } else {
        ctx.fillStyle = bodyColor
        ctx.fillRect(x, y, w, h)
      }
    }
  }

  const drawHeadEyes = (cx, cy, scale = 1) => {
    // eye offset depends on direction
    const dx = State.dir.x
    const dy = State.dir.y
    const lookX = dx * 4
    const lookY = dy * 4

    // eyes move slightly with scale
    const eyeY = -4 * scale
    const eyeX = 4 * scale

    // whites
    ctx.fillStyle = "#fff"
    ctx.beginPath()
    ctx.arc(cx - eyeX + lookX, cy + eyeY + lookY, 2.2 * scale, 0, Math.PI * 2)
    ctx.arc(cx + eyeX + lookX, cy + eyeY + lookY, 2.2 * scale, 0, Math.PI * 2)
    ctx.fill()

    // pupils
    ctx.fillStyle = "#000"
    ctx.beginPath()
    ctx.arc(cx - eyeX + lookX, cy + eyeY + lookY, 1.1 * scale, 0, Math.PI * 2)
    ctx.arc(cx + eyeX + lookX, cy + eyeY + lookY, 1.1 * scale, 0, Math.PI * 2)
    ctx.fill()
  }

  const drawDeath = (t) => {
    if (!State.death) return
    const { t: t0, dur, particles } = State.death
    const p = (t - t0) / dur

    // clear normal snake/food in dying mode (we render crumble only)
    const accent = getComputedStyle(document.body).getPropertyValue("--accent").trim()
    ctx.fillStyle = accent

    // physics step by dt-ish (simple, stable)
    for (const pt of particles) {
      pt.x += pt.vx
      pt.y += pt.vy
      pt.vy += 0.06  // gravity feel
      pt.life = 1 - p

      // draw (fade by skipping some pixels near end - retro dissolve)
      if (pt.life > 0.15 || Math.random() > 0.4) {
        ctx.fillRect(Math.round(pt.x), Math.round(pt.y), pt.size, pt.size)
      }
    }

    if (p >= 1) {
      State.death = null
      endGame()
    }
  }

  const render = (t) => {
    const canvasBg = getComputedStyle(document.body).getPropertyValue("--canvas").trim()
    ctx.fillStyle = canvasBg
    ctx.fillRect(0, 0, canvas.width, canvas.height)
    drawGrid()

    if (State.mode === "dying") {
      drawDeath(t)
    } else {
      drawFood()
      drawPop(t)
      drawSnake(t)
    }

    requestAnimationFrame(render)
  }

  // Main loop: fixed tick + rAF render
  const loop = () => {
    const t = now()
    if (t - lastTick >= TICK_MS) {
      lastTick = t
      tick()
    }
    requestAnimationFrame(loop)
  }

  // Inputs
  const bindButton = (selector, x, y) => {
    document.querySelector(selector).onpointerdown = () => setDir(x, y)
  }
  bindButton(".up", 0, -1)
  bindButton(".down", 0, 1)
  bindButton(".left", -1, 0)
  bindButton(".right", 1, 0)

  document.addEventListener("keydown", (e) => {
    const k = e.key
    if (k === "ArrowUp" || k === "w" || k === "W") setDir(0, -1)
    if (k === "ArrowDown" || k === "s" || k === "S") setDir(0, 1)
    if (k === "ArrowLeft" || k === "a" || k === "A") setDir(-1, 0)
    if (k === "ArrowRight" || k === "d" || k === "D") setDir(1, 0)
    if (k === " " || k === "Enter") {
      // quick pause toggle on desktop (safe)
      if (State.mode === "playing" || State.mode === "paused") togglePause()
    }
  })

  // Swipe on canvas
  let sx = 0, sy = 0
  canvas.addEventListener("pointerdown", (e) => { sx = e.clientX; sy = e.clientY })
  canvas.addEventListener("pointerup", (e) => {
    const dx = e.clientX - sx
    const dy = e.clientY - sy
    if (Math.abs(dx) < 18 && Math.abs(dy) < 18) return
    if (Math.abs(dx) > Math.abs(dy)) setDir(dx > 0 ? 1 : -1, 0)
    else setDir(0, dy > 0 ? 1 : -1)
  })

  // UI actions
  UI.pause.onpointerdown = () => togglePause()
  UI.theme.onpointerdown = () => document.body.classList.toggle("light")

  UI.sound.onpointerdown = async () => {
    // ensure audio initialized so toggle immediately usable after first tap
    await initAudio()
    soundOn = !soundOn
    localStorage.setItem("malorisa_sound", soundOn ? "1" : "0")
    UI.sound.textContent = soundOn ? "üîä" : "üîá"
    beep(520, 0.08)
  }

  UI.play.onpointerdown = async () => {
    await initAudio()
    beep(440, 0.14)
    UI.start.style.display = "none"
    startGame()
  }

  UI.restart.onpointerdown = async () => {
    await initAudio()
    beep(440, 0.14)
    UI.over.style.display = "none"
    startGame()
  }

  // Start render + loop
  requestAnimationFrame(render)
  requestAnimationFrame(loop)
})()
</script>

</body>
</html>

